# 8 - Diffie-Hellman

## 8.1 Groups, Cyclic and subgroups 
Understanding the functionality of groups, cyclic groups and subgroups is important for the use of public-key cryptosystems based on the discrete logarithm
problem. That’s why we are going to practice some arithmetic in such structures
in this set of problems.
Let’s start with an easy one. Determine the order of all elements of the multi-
plicative groups of:

1. Z∗5
- 1 4 4 1
2. Z∗7
- 1 4 2 2 4 1
3. Z∗13
- 1 4 9 3 12 10 10 12 3 9 4 1

[Ejemplo](https://github.com/JorgeFigueroa-Iteso/Cripto-1/blob/main/DIFFIE-HELLMAN/8.1Ejemplo.py)

## 8.2 Elements

We consider the group Z∗53 . What are the possible element orders? How many
elements exist for each order?

- 53 Elementos, 52 Ordenes

[8.2.py](https://github.com/JorgeFigueroa-Iteso/Cripto-1/blob/main/DIFFIE-HELLMAN/8.2.py)

## 8.3 From the subgroups

We now study the groups from Problem 8.2.
1. How many elements does each of the multiplicative groups have?
- Z * 5= 4
- Z * 7=6
- Z * 13=12

2. Do all orders from above divide the number of elements in the corresponding multiplicative group?
- Sí

3. Which of the elements from Problem 8.1 are primitive elements?
- Z * 5: [2, 3]
- Z * 7: [3, 5]
- Z * 13: [2, 6, 7, 11]

4. Verify for the groups that the number of primitive elements is given by φ (|Z∗p|)
- φ (4) = 2
- φ (6) = 2
- φ (12)= 4

## 8.4 Generators

 In this exercise we want to identify primitive elements (generators) of a multi-plicative group since they play a big role in the DHKE and and many other public-key schemes based on the DL problem. You are given a prime p = 4969 and the
corresponding multiplicative group Z∗4969 .
1. Determine how many generators exist in Z∗4969.
- 1584

2. What is the probability of a randomly chosen element a ∈ Z∗4969 being a genera-tor?
- 31.87%

3. Determine the smallest generator a ∈ Z∗4969 with a > 1000.
Hint: The identification can be done na¨ıvely through testing all possible factors of the group cardinality p − 1, or more efficiently by checking the premise that a(p−1)/q i = 1 mod p for all prime factors qi with p − 1 = ∏ qe
ii . You can simply start with a = 1001 and repeat these steps until you find a respective generator of Z∗4969 .
- 11

4. What measures can be taken in order to simplify the search for generators for arbitrary groups Z∗p?
- Se puede hacer una lista de los generadores de los grupos y buscar en esa lista

## 8.5  Compute the two public keys and the common key for the DHKE scheme with the parameters p = 467, α = 2, and

1. a = 3, b = 5
ka: 8, kb: 32, kab: 78 == kba: 78

2. a = 400, b = 134
ka: 137, kb: 84, kab: 90 == kba: 90

3. a = 228, b = 57
ka: 394, kb: 313, kab: 206 == kba: 206

[8.5.py](https://github.com/JorgeFigueroa-Iteso/Cripto-1/blob/main/DIFFIE-HELLMAN/8.5.py)

## 8.6 We now design another DHKE scheme with the same prime p = 467 as in Problem 8.5. This time, however, we use the element α = 4. The element 4 has order 233 and generates thus a subgroup with 233 elements. Compute kAB for
1. a = 400, b = 134
- [+] ka: 89
- [+] kb: 51
- [+] kab: 161 == kba: 161

2. a = 167, b = 134
- [+] ka: 89
- [+] kb: 51
- [+] kab: 161 == kba: 161

Why are the session keys identical?
- Porque no son numeros generadores, esto es que se repiten los números en mod,lo que puede crear de 2 a más llaves que lleven al mismo resultado.

## 8.7 Weaknesses

In the DHKE protocol, the private keys are chosen  from the set {2, . . . , p − 2}.
Why are the values 1 and p − 1 excluded? Describe the weakness of these two values.

Ambos valores generarían claves públicas que permitirían reconocer inmediatamente la clave privada. Si la clave privada es igual a 1, la clave pública sería idéntica al elemento primitivo α. Si un atacante detecta esta identidad, sabría que kpr=1kpr​=1. Si la clave privada es igual a p−1p−1, la clave pública tomaría el valor 1 de acuerdo con el Pequeño Teorema de Fermat. Si un atacante se da cuenta de esto, puede deducir que kpr=p−1kpr​=p−1.

## 8.9 Generators

We now want to consider the importance of the proper choice of generators in multiplicative groups.
1. Show that the order of an element a ∈ Z p with a = p − 1 is always 2.

![IMG](https://github.com/JorgeFigueroa-Iteso/Cripto-1/blob/main/DIFFIE-HELLMAN/Sin%20t%C3%ADtulo.png)

2. What subgroup is generated by a?
Ha = {1, p-1}

3. Briefly describe a simple attack on the DHKE which exploits this property.
Un ataque de ManInTheMiddle, ya que al hacerse pasar por "A", o "B" este puede crear dos llaves, uno para cada uno, y así ver y mandar el contenido de cada lado

## 8.10 Galois

We consider a DHKE protocol over a Galois fields GF(2 m ). All arithmetic
is done in GF(2 5 ) with P(x) = x 5 + x 2 + 1 as an irreducible field polynomial. The primitive element for the Diffie–Hellman scheme is α = x 2 . The private keys are a = 3 and b = 12. What is the session key k AB ?

![IMG](https://github.com/JorgeFigueroa-Iteso/Cripto-1/blob/main/DIFFIE-HELLMAN/2.png)

## 8.11 Ataque

En un protocolo Diffie-Hellman estándar:

    Alice y Bob acuerdan públicamente en un número primo pp y una base gg.
    Alice selecciona un número privado aa y calcula A=gamod  pA=gamodp.
    Bob selecciona un número privado bb y calcula B=gbmod  pB=gbmodp.
    Alice y Bob intercambian AA y BB, y usan estos valores para calcular el secreto compartido: S=Abmod  p=Bamod  pS=Abmodp=Bamodp.

Ataque de Oscar:

    Intercepción:
    Oscar se coloca en el medio de la comunicación entre Alice y Bob.

    Manipulación de Mensajes:
        Alice calcula A=gamod  pA=gamodp y lo envía a Bob, pero Oscar intercepta AA y envía su propio valor O1=g1omod  pO1​=g1o​modp a Bob.
        Bob calcula B=gbmod  pB=gbmodp y lo envía a Alice, pero Oscar intercepta BB y envía su propio valor O2=g2omod  pO2​=g2o​modp a Alice.

    Cálculo de Claves:
        Alice recibe O2O2​, piensa que es BB, y calcula el secreto compartido como S1=(O2)amod  pS1​=(O2​)amodp.
        Bob recibe O1O1​, piensa que es AA, y calcula el secreto compartido como S2=(O1)bmod  pS2​=(O1​)bmodp.
        Oscar puede ahora calcular S1=(O2)1omod  pS1​=(O2​)1o​modp y S2=(O1)2omod  pS2​=(O1​)2o​modp, ya que él conoce o1o1​ y o2o2​.

    Desencriptación y Reencriptación:
        Alice y Bob creen que tienen un secreto compartido y comienzan a enviar mensajes cifrados usando este secreto.
        Oscar puede descifrar estos mensajes usando los secretos compartidos que ha calculado, modificar los mensajes si lo desea, y reencriptarlos usando los secretos compartidos antes de reenviarlos.

    Finalización:
        Alice y Bob creen que están comunicándose de forma segura entre ellos cuando en realidad están comunicándose con Oscar.

## 8.12 Discrete Log

Write a program which computes the discrete logarithm in Z ∗ p by exhaustive
search. The input parameters for your program are p, α , β . The program computes
x where β = α x mod p.

Compute the solution to log 106 12375 in Z 24691 .

[Log](https://github.com/JorgeFigueroa-Iteso/Cripto-1/blob/main/DIFFIE-HELLMAN/8.12.py)

## 8.13 Encrypt & Decrypt

Encrypt the following messages with the Elgamal scheme (p = 467 and α = 2):

1. k pr = d = 105, i = 213, x = 33
2. k pr = d = 105, i = 123, x = 33
3. k pr = d = 300, i = 45, x = 248
4. k pr = d = 300, i = 47, x = 248

Now decrypt every ciphertext and show all steps.

[+] 1
[+] y's: (29, 296)
[+] x: 33

[+] 2
[+] y's: (125, 301)
[+] x: 33

[+] 3
[+] y's: (80, 174)
[+] x: 248

[+] 4
[+] y's: (320, 139)
[+] x: 248

[8.13.py](https://github.com/JorgeFigueroa-Iteso/Cripto-1/blob/main/DIFFIE-HELLMAN/8.13.py)

## 8.14  Elagmal

Assume Bob sends an Elgamal encrypted message to Alice. Wrongly, Bob
uses the same parameter i for all messages. Moreover, we know that each of Bob’s
cleartexts start with the number x 1 = 21 (Bob’s ID). We now obtain the following
ciphertexts
(k E,1 = 6, y 1 = 17),
(k E,2 = 6, y 2 = 25).
The Elgamal parameters are p = 31, α = 3, β = 18. Determine the second plaintext
x 2 .

[8_14.py](https://github.com/JorgeFigueroa-Iteso/Cripto-1/blob/main/DIFFIE-HELLMAN/8_14.py)

## 8.15 

Given is an Elgamal crypto system. Bob tries to be especially smart and
chooses the following pseudorandom generator to compute new i values:
i j = i j−1 + f ( j) , 1 ≤ j
(8.5)
where f ( j) is a “complicated” but known pseudorandom function (for instance, f ( j)
could be a cryptographic hash function such as SHA or RIPE-MD160). i 0 is a true
random number that is not known to Oscar.
Bob encrypts n messages x j as follows:
k E j = α i j mod p,
y j = x j · β i j mod p,
where 1 ≤ j ≤ n. Assume that the last cleartext x n is known to Oscar and all cipher-
text.
Provide a formula with which Oscar can compute any of the messages x j , 1 ≤
j ≤ n − 1. Of course, following Kerckhoffs’ principle, Oscar knows the construction
method shown above, including the function f ()

[8_15.py](https://github.com/JorgeFigueroa-Iteso/Cripto-1/blob/main/DIFFIE-HELLMAN/8_15.py)
